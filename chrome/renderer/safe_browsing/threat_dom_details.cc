// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/renderer/safe_browsing/threat_dom_details.h"

#include <map>

#include "base/compiler_specific.h"
#include "base/strings/stringprintf.h"
#include "components/safe_browsing/common/safebrowsing_messages.h"
#include "content/public/renderer/render_frame.h"
#include "third_party/WebKit/public/platform/WebString.h"
#include "third_party/WebKit/public/web/WebDocument.h"
#include "third_party/WebKit/public/web/WebElement.h"
#include "third_party/WebKit/public/web/WebElementCollection.h"
#include "third_party/WebKit/public/web/WebFrame.h"
#include "third_party/WebKit/public/web/WebLocalFrame.h"

namespace safe_browsing {

// A map for keeping track of the identity of DOM Elements, used to generate
// unique IDs for each element and lookup elements IDs by parent Element, to
// maintain proper parent/child relationships.
// They key is a WebNode from the DOM, which is basically a pointer so can be
// copied into the map when inserting new elements.
// The values are pointers to IPC messages generated by ThreatDOMDetails. They
// are not owned by the map - ownership remains with the vector of resources
// collected by this class.
typedef std::map<blink::WebNode, SafeBrowsingHostMsg_ThreatDOMDetails_Node*>
    ElementToNodeMap;

namespace {

// Handler for the various HTML elements that we extract URLs from.
void HandleElement(
    const blink::WebElement& element,
    SafeBrowsingHostMsg_ThreatDOMDetails_Node* parent_node,
    std::vector<SafeBrowsingHostMsg_ThreatDOMDetails_Node>* resources,
    safe_browsing::ElementToNodeMap* element_to_node_map) {
  if (!element.hasAttribute("src"))
    return;

  // Retrieve the link and resolve the link in case it's relative.
  blink::WebURL full_url =
      element.document().completeURL(element.getAttribute("src"));

  const GURL& child_url = GURL(full_url);

  // Add to the parent node.
  parent_node->children.push_back(child_url);

  // Create the child node.
  resources->push_back(SafeBrowsingHostMsg_ThreatDOMDetails_Node());
  SafeBrowsingHostMsg_ThreatDOMDetails_Node* child_node = &resources->back();
  child_node->url = child_url;
  child_node->tag_name = element.tagName().utf8();
  child_node->parent = parent_node->url;

  // Update the ID mapping. First generate the ID for the current node.
  // Then, if its parent is available, set the current node's parent ID, and
  // also update the parent's children with the current node's ID.
  const int child_id = element_to_node_map->size() + 1;
  child_node->node_id = child_id;
  if (!element.parentNode().isNull()) {
    auto parent_node_iter = element_to_node_map->find(element.parentNode());
    if (parent_node_iter != element_to_node_map->end()) {
      child_node->parent_node_id = parent_node->node_id;
      parent_node->child_node_ids.push_back(child_id);
    }
  }
  (*element_to_node_map)[element] = child_node;
}

}  // namespace

// An upper limit on the number of nodes we collect.
uint32_t ThreatDOMDetails::kMaxNodes = 500;

// static
ThreatDOMDetails* ThreatDOMDetails::Create(content::RenderFrame* render_frame) {
  // Private constructor and public static Create() method to facilitate
  // stubbing out this class for binary-size reduction purposes.
  return new ThreatDOMDetails(render_frame);
}

ThreatDOMDetails::ThreatDOMDetails(content::RenderFrame* render_frame)
    : content::RenderFrameObserver(render_frame) {}

ThreatDOMDetails::~ThreatDOMDetails() {}

bool ThreatDOMDetails::OnMessageReceived(const IPC::Message& message) {
  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP(ThreatDOMDetails, message)
    IPC_MESSAGE_HANDLER(SafeBrowsingMsg_GetThreatDOMDetails,
                        OnGetThreatDOMDetails)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()
  return handled;
}

void ThreatDOMDetails::OnGetThreatDOMDetails() {
  std::vector<SafeBrowsingHostMsg_ThreatDOMDetails_Node> resources;
  ExtractResources(&resources);
  // Notify the browser.
  Send(new SafeBrowsingHostMsg_ThreatDOMDetails(routing_id(), resources));
}

void ThreatDOMDetails::ExtractResources(
    std::vector<SafeBrowsingHostMsg_ThreatDOMDetails_Node>* resources) {
  blink::WebFrame* frame = render_frame()->GetWebFrame();
  if (!frame)
    return;
  SafeBrowsingHostMsg_ThreatDOMDetails_Node details_node;
  blink::WebDocument document = frame->document();
  details_node.url = GURL(document.url());
  if (document.isNull()) {
    // Nothing in this frame. Just report its URL.
    resources->push_back(details_node);
    return;
  }

  ElementToNodeMap element_to_node_map;
  blink::WebElementCollection elements = document.all();
  blink::WebElement element = elements.firstItem();
  for (; !element.isNull(); element = elements.nextItem()) {
    if (element.hasHTMLTagName("iframe") || element.hasHTMLTagName("frame") ||
        element.hasHTMLTagName("embed") || element.hasHTMLTagName("script")) {
      HandleElement(element, &details_node, resources, &element_to_node_map);
      if (resources->size() >= kMaxNodes) {
        // We have reached kMaxNodes, exit early.
        resources->push_back(details_node);
        return;
      }
    }
  }
  resources->push_back(details_node);
}

void ThreatDOMDetails::OnDestruct() {
  delete this;
}

}  // namespace safe_browsing
